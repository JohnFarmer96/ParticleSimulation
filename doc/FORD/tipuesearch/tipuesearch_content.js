var tipuesearch = {"pages":[{"title":" Fortran Program ","text":"Fortran Program ParticleSimulation ParticleSimulation is a university project created by Jonathan Bauer.\nThe shared source-code aims to resemble the skills that are taught in the lecture \"Anwendung höherer Programmiersprachen\" by Daniel Weygand at the Karlsruhe Institute of Technology (KIT).\nThe project is capable of numerically simulate the movement of aerosoles [50nm - 100 µm] affected by gravitation, evaporation, wind and air-resistance. Project Structure The main structure divides up into two parts: 1. Simulation Program (Fortran Based) For the sake of efficiency the mathematical problems is executed by a fortran based program that is stored in \"dist/\" directory.\nThe program is precompiled (GNU-Fortran-Compiler) and ready to be executed, which can be achieved by calling $ make run If the provided distribution doesn't match your CPU-architecture, it can be re-compiled by calling $ make build Make sure GNU-Fortran-Compiler is installed ( https://gcc.gnu.org/ ). The simulation-parameters for the Fortran-Program can be adapted in \"data/config.d\" for the desired context: concentration [1] (Number of Particles in Simulation) t_total [s] ( Total Simulation Time) t_resolution [s] (Time Resolution of Data Output) v_x [m/s] (Initial Velocity in X-Direction) v_y [m/s] (Initial Velocity in Y-Direction) v_z [m/s] (Initial Velocity in Z-Direction) v_wind_x [m/s] (Wind Velocity in X-Direction) v_wind_y [m/s] (Wind Velocity in Y-Direction) v_wind_z [m/s] (Wind Velocity in Z-Direction) humidity [%] (ranging from 0 to 1) (Humidity of Environment) T_environment [K] (Temperature of Environment) After each iteration the current data is stored in a file named 'particle_simulation_result_XX.dat' where 'XX' is a placeholder for the current iteration step. While stepwidth of the numeric proceduers is calculated automatically, the total number of iterations is determined by the total simulation time and the selected time resolution. 2. Data Processing and Visualization (Python Based) The resulting data is processed and visualized by Python Code.\nThe code can be executed in two ways: Jupyter Notebook (~python/main.ipynb) Plain Python Script (~python/main.py) The provided source code outputs plots showing the movement at a certain timestamp (3D) and pre-selected single features over the entire simulation-duration (2D).\nAn example snippet is shown below (Green: particles still in the air, Red: particles on the ground) . Documentation The documentation of physical and mathematical foundations can be reviewed in the \"doc/\" directory as well as the module-structure of the Fortran Code.\nBoth - Fortran and Python - Codes are annotated in detail and therefore easy to follow along. Get Started To download the project run: $ git clone https://github.com/JohnFarmer96/ParticleSimulation After the project is stored locally you can explore the behaviour by executing the make-commands mentioned above or the provided shell script $ ./execute.sh Developer Info Jonathan Bauer Mechanical Engineering Student.","tags":"home","loc":"index.html"},{"title":"module_parameters.f90 – Fortran Program","text":"Contents Modules module_parameters Source Code module_parameters.f90 Source Code MODULE module_parameters !! Define global parameters IMPLICIT NONE PUBLIC :: rho_air PUBLIC :: nu_air PUBLIC :: etha_air ! Dimension of Simulation INTEGER , PARAMETER :: dim = 3 ! PHYSICAL PARAMETERS ! ======================================================== ! Gravitational Acceleration [m/s²] DOUBLE PRECISION , DIMENSION ( dim ) :: g = ( / 0.0 , 0.0 , - 9.80665 / ) ! Gas Constant [kg⋅m²·K⁻¹⋅mol⁻¹⋅s⁻²] DOUBLE PRECISION , PARAMETER :: R = 8.31446261815324 ! Standard Atmosphere [Pa = kg/(m⋅s²)] DOUBLE PRECISION , PARAMETER :: p_atm = 101325 ! Molar Mass (Water) [kg/mol] DOUBLE PRECISION , PARAMETER :: M_H2O = 1 8.01538 * 1E-3 ! Molar Mass (Dry Air) [kg/mol] DOUBLE PRECISION , PARAMETER :: M_air = 2 8.9644 * 1E-3 ! Density of Water [kg/m³] [fg/µm³] DOUBLE PRECISION , PARAMETER :: rho_H20 = 1000 ! Density of SARS-CoV-2 [kg/m³] [fg/µm³] DOUBLE PRECISION , PARAMETER :: rho_cov2 = 1000 ! Base Diffusion Coefficient at 0°C [m²/s] DOUBLE PRECISION , PARAMETER :: D_0 = 2.3 * 1E-5 ! Corresponding Temperature T_0 at 0°C [K] DOUBLE PRECISION , PARAMETER :: T_0 = 27 3.15 ! Antoine Equation Parameters (H2O) DOUBLE PRECISION , PARAMETER :: A = 8.07131 DOUBLE PRECISION , PARAMETER :: B = 173 0.63 DOUBLE PRECISION , PARAMETER :: C = 23 3.426 DOUBLE PRECISION , PARAMETER :: mmHg_Pa_conversion = 13 3.32 ! ======================================================== ! MATHEMATICAL PARAMETERS ! ======================================================== ! Assign Pi to constant Value DOUBLE PRECISION , PARAMETER :: PI = 4.d0 * DATAN ( 1.d0 ) ! ======================================================== CONTAINS ! Density of Air [kg/m³] [fg/µm³] FUNCTION rho_air ( T_environment ) ! Temperature ov environment [K] DOUBLE PRECISION , INTENT ( IN ) :: T_environment ! Density of Air [kg/m³] DOUBLE PRECISION :: rho_air ! Ideal Gas Law rho_air = p_atm * M_air / ( R * T_environment ) END FUNCTION ! Kinematic Viscosity [m²/s] FUNCTION nu_air ( T_environment ) ! Temperature ov environment [K] DOUBLE PRECISION , INTENT ( IN ) :: T_environment ! Density of Air [kg/m³] DOUBLE PRECISION :: nu_air ! Ideal Gas Law nu_air = etha_air ( T_environment ) / rho_air ( T_environment ) END FUNCTION ! Dynamic viscosity [Pa⋅s = kg/(m⋅s)] (Interpolation) ! Source: https://www.engineersedge.com/physics/viscosity_of_air_dynamic_and_kinematic_14483.htm FUNCTION etha_air ( T_environment ) ! Temperature ov environment [K] DOUBLE PRECISION , INTENT ( IN ) :: T_environment ! Density of Air [kg/m³] DOUBLE PRECISION :: etha_air ! Parameters DOUBLE PRECISION , PARAMETER :: offset = 1.338 * 1E-5 DOUBLE PRECISION , PARAMETER :: gradient = 0.968 * 1E-7 ![Pa*s/K] ! Linear Interpolation (acc. to graph in source) etha_air = gradient * ( T_environment - T_0 ) + offset END FUNCTION END MODULE module_parameters","tags":"","loc":"sourcefile/module_parameters.f90.html"},{"title":"module_force.f90 – Fortran Program","text":"Contents Modules module_force Source Code module_force.f90 Source Code MODULE module_force !! Calculate Acting Force on Particle use module_parameters USE module_particle IMPLICIT NONE PUBLIC :: evaluate_force PRIVATE :: reset PRIVATE :: gravitation PRIVATE :: air_resistance PRIVATE :: wind CONTAINS SUBROUTINE evaluate_force ( prtcl ) !! Update Acting Force on Particle (required in each step) [µN = µg*m/s²] TYPE ( particle ), INTENT ( INOUT ) :: prtcl !! Desired particle ! Delete old Value call reset ( prtcl ) ! Add gravitation-force call gravitation ( prtcl ) ! Add air-resistance-force call air_resistance ( prtcl ) ! Add wind-force call wind ( prtcl ) END SUBROUTINE ! Reinitialize acting force [µN = µg*m/s²] SUBROUTINE reset ( prtcl ) ! Desired particle TYPE ( particle ), INTENT ( INOUT ) :: prtcl ! Set to 0 prtcl % f = 0 END SUBROUTINE SUBROUTINE gravitation ( prtcl ) !! Calculate gravitational force [µN = µg*m/s²] TYPE ( particle ), INTENT ( INOUT ) :: prtcl !! Desired particle ! Conversion factor (fg to µg) DOUBLE PRECISION , PARAMETER :: conversion = 1E-9 ! Newton Law prtcl % f = prtcl % f + ( mass_core ( prtcl ) + mass_shell ( prtcl )) * g * conversion END SUBROUTINE SUBROUTINE air_resistance ( prtcl ) !! Calculate air resistance force [µN = µg*m/s²] TYPE ( particle ), INTENT ( INOUT ) :: prtcl !! Desired particle ! Conversion factor (kg to µg and µm to m) DOUBLE PRECISION , PARAMETER :: conversion = 1E3 ! Cunningham Correction (dimensionless) DOUBLE PRECISION :: ccorr ! Air Resistance Force Vector (Automatic stepwidth) DOUBLE PRECISION , DIMENSION ( dim ) :: f_r ! Stokes Law and Cunningham Correction (particles very small) ccorr = 1 + 1.63 * 0.068 / prtcl % d_shell f_r = 6 * PI * etha_air ( prtcl % T_environment ) * ( prtcl % d_shell / 2 ) * prtcl % v * ( - 1 ) * conversion / ccorr prtcl % f = prtcl % f + f_r ! Dynamically set stepwidth [s] call set_dt ( prtcl , sqrt ( sum ( f_r ** 2 ))) END SUBROUTINE SUBROUTINE wind ( prtcl ) !! Calculate wind force [µN = µg*m/s²] TYPE ( particle ), INTENT ( INOUT ) :: prtcl !! Desired particle ! Conversion factor (kg to µg and µm to m) DOUBLE PRECISION , PARAMETER :: conversion = 1E-3 ! Wind Force on particle prtcl % f = prtcl % f + rho_air ( prtcl % T_environment ) / 2 * ( prtcl % v_wind ) ** 2 * (( prtcl % d_shell / 2 ) ** 2 * PI ) * conversion END SUBROUTINE END MODULE module_force","tags":"","loc":"sourcefile/module_force.f90.html"},{"title":"main.f90 – Fortran Program","text":"Contents Programs main Source Code main.f90 Source Code PROGRAM main !! Main Simulation Program USE numeric_integration USE particle_simulation IMPLICIT NONE CHARACTER ( LEN = 128 ), PARAMETER :: config_file = 'data/config.d' !! Relative Path to Configuration file CHARACTER ( LEN = 128 ), PARAMETER :: base_path = 'data/particle_simulation_result_' !! Relative Path to Result files (Extension needs to be added) INTEGER , PARAMETER :: num_of_variables = 23 !! Hard Coded Number of Variables that are present in output data array ! CONFIG-PARAMETERS ! ============================================================== INTEGER :: concentration !! Particle concentration in the air [x/m³] (0...30.000) DOUBLE PRECISION , DIMENSION ( dim ) :: velocity !! Intensity coefficient [%] (0...1) DOUBLE PRECISION , DIMENSION ( dim ) :: v_wind !! Velocity of Wind [m/s] DOUBLE PRECISION :: T_environment !! Temperature of environment [K] DOUBLE PRECISION :: humidity !! Relative Humidity in environment [%] (0...1) DOUBLE PRECISION :: t_total !! Total Simulation Time [s] ! ============================================================== DOUBLE PRECISION , DIMENSION (:,:), ALLOCATABLE :: data_array !! Output Data Array LOGICAL :: all_done !! Stop Simulation LOGICAL :: breakpoint !! Time breakpoint to print values DOUBLE PRECISION :: t_resolution !! Time resolution DOUBLE PRECISION :: timestamp !! Current timestamp INTEGER :: n_cur !! Number of Iterations ! SIMULATION =================================================== print * , \"Started\" ! Read Parameters & Apply Configuration call read_config ( TRIM ( config_file )) ALLOCATE ( data_array ( concentration , num_of_variables )) print * , \"Preparation Completed\" ! Initialize Particles n_cur = 0 call initialize ( concentration , velocity , T_environment , humidity , v_wind ) print * , \"Initialization Complete\" ! Save initial configuration data_array = output ( start_idx = 1 , end_idx = concentration ) call write_to_file ( base_path , n_cur ) print * , \"Initialization Saved\" ! Execute Simulation all_done = . FALSE . breakpoint = . FALSE . timestamp = t_resolution n_cur = 0 print * , \"Simulation Started\" do while ( all_done . eqv . . FALSE .) call update ( euler , euler , t_total , all_done , timestamp , breakpoint ) IF ( breakpoint . EQV . . TRUE .) THEN n_cur = n_cur + 1 timestamp = timestamp + t_resolution ! Write result data_array = output ( start_idx = 1 , end_idx = concentration ) call write_to_file ( base_path , n_cur ) END IF end do print * , \"Simulation Completed\" ! Print Success print * , \"Program Done\" ! END SIMULATION =============================================== CONTAINS SUBROUTINE read_config ( filename ) !! Read in parameter configuration from file CHARACTER ( len =* ), INTENT ( IN ) :: filename !! Filename INTEGER :: ios , unit_no ! Open Textfile & Verify Success OPEN ( newunit = unit_no , file = TRIM ( filename ), status = 'unknown' , IOSTAT = ios ) if ( ios /= 0 ) then print * , \"Cannot Open File. IO-Status-Variable Value:\" , ios STOP end if ! Read in process variables read ( unit_no , * ) concentration print * , \"Concentration: \" , concentration read ( unit_no , * ) t_total print * , \"Total Time: \" , t_total read ( unit_no , * ) t_resolution print * , \"Time Resolution: \" , t_resolution read ( unit_no , * ) velocity ( 1 ) print * , \"Stepwidth: \" , velocity ( 1 ) read ( unit_no , * ) velocity ( 2 ) print * , \"Total Time: \" , velocity ( 2 ) read ( unit_no , * ) velocity ( 3 ) print * , \"Total Time: \" , velocity ( 3 ) read ( unit_no , * ) v_wind ( 1 ) print * , \"Velocity of Wind (x): \" , v_wind ( 1 ) read ( unit_no , * ) v_wind ( 2 ) print * , \"Velocity of Wind (y): \" , v_wind ( 2 ) read ( unit_no , * ) v_wind ( 3 ) print * , \"Velocity of Wind (z): \" , v_wind ( 3 ) read ( unit_no , * ) humidity print * , \"Humidity: \" , humidity read ( unit_no , * ) T_environment print * , \"Temperature of Environment \" , T_environment ! Close File Before Ending CLOSE ( unit_no ) END SUBROUTINE SUBROUTINE write_to_file ( filename_base , n_current ) !! Write data to file CHARACTER ( len =* ), INTENT ( IN ) :: filename_base !! File-Basename INTEGER , INTENT ( IN ) :: n_current !! Current iteration number INTEGER :: idx , ios , unit_no ! Adapt filename CHARACTER ( LEN = 128 ) :: filename CHARACTER ( LEN = 128 ) :: filename_suffix CHARACTER ( LEN = 20 ) :: FMT IF ( n_current . GT . 0 ) THEN WRITE ( FMT , '(\"(I\", I0, \")\")' ) INT ( LOG10 ( REAL ( n_current )) + 1 ) WRITE ( filename_suffix , FMT ) n_current ELSE WRITE ( filename_suffix , '(I1)' ) 0 END IF filename = TRIM ( filename_base ) // TRIM ( filename_suffix ) // '.dat' print * , \"Writing at: \" // filename ! Open Textfile & Verify Success OPEN ( newunit = unit_no , file = TRIM ( filename ), status = 'replace' , IOSTAT = ios ) if ( ios /= 0 ) then print * , \"Cannot Open File. IO-Status-Variable Value:\" , ios STOP end if ! Write out Headline WRITE ( unit_no , '(23(a18))' ) \"idx\" , \"time\" , \"r_x\" , \"r_y\" , \"r_z\" , \"v_x\" , \"v_y\" , \"v_z\" , \"d_core\" ,& \"d_shell\" , \"T_par\" , \"T_env\" , \"humid\" , \"vw_x\" , \"vw_y\" , \"vw_z\" , \"m_c\" , \"m_s\" , \"f_x\" , \"f_y\" , \"f_z\" , \"core\" , \"active\" ! Write out Variables do idx = 1 , concentration write ( unit_no , '(23(g18.7))' ) data_array ( idx ,:) end do ! Close File Before Ending CLOSE ( unit_no ) END SUBROUTINE SUBROUTINE print_output ( array ) !! Print array to console DOUBLE PRECISION , DIMENSION ( concentration , num_of_variables ), INTENT ( IN ) :: array !! Desired Array INTEGER :: idx print '(23(a14))' , \"idx\" , \"time\" , \"r_x\" , \"r_y\" , \"r_z\" , \"v_x\" , \"v_y\" , \"v_z\" , \"d_core\" ,& \"d_shell\" , \"T_par\" , \"T_env\" , \"humid\" , \"vw_x\" , \"vw_y\" , \"vw_z\" , \"f_x\" , \"f_y\" , \"f_z\" , \"core\" , \"active\" do idx = 1 , concentration print '(21(g14.6))' , array ( idx ,:) end do END SUBROUTINE END PROGRAM","tags":"","loc":"sourcefile/main.f90.html"},{"title":"module_movement.f90 – Fortran Program","text":"Contents Modules module_movement Source Code module_movement.f90 Source Code MODULE module_movement !! Calculate movement of particle USE module_parameters USE module_particle USE module_force USE numeric_integration IMPLICIT NONE PUBLIC :: evaluate_movement PRIVATE :: dydt CONTAINS SUBROUTINE evaluate_movement ( numeric_integration_procedure , prtcl , t_total ) !! Update Particle Movement [location: m, velocity: m/s, acceleration: m/s²] PROCEDURE ( num_int_procedure ) :: numeric_integration_procedure !! Desired numeric integration procedure (Euler, Runge-Kutta, ...) TYPE ( particle ), INTENT ( INOUT ) :: prtcl !! Desired particle DOUBLE PRECISION , INTENT ( IN ) :: t_total !! Indicate if all particles are simulated ! Key Value DOUBLE PRECISION , DIMENSION ( 2 * dim ) :: y ! Parameter Array for Function Arguments DOUBLE PRECISION , DIMENSION ( 4 ) :: params ! Prepare function arguments y ( 1 : SIZE ( y , DIM = 1 ) / 2 ) = prtcl % r y ( SIZE ( y , DIM = 1 ) / 2 + 1 :) = prtcl % v ! Evaluate Force and Adapt Stepwidth call evaluate_force ( prtcl ) params ( 1 ) = prtcl % f ( 1 ) ![µN] params ( 2 ) = prtcl % f ( 2 ) ![µN] params ( 3 ) = prtcl % f ( 3 ) ![µN] params ( 4 ) = ( mass_core ( prtcl ) + mass_shell ( prtcl )) ![fg] ! Update Key Value call numeric_integration_procedure ( dydt , y , prtcl % dt , params , SIZE ( params , DIM = 1 ), SIZE ( y , DIM = 1 )) ! Store Changes prtcl % r = y ( 1 :( 2 * dim ) / 2 ) prtcl % v = y (( 2 * dim ) / 2 + 1 :) ! Verify Changes call verify_status ( prtcl , t_total ) END SUBROUTINE FUNCTION dydt ( y , params , params_dim , alg_dim ) !! 1st order Derivative of State-Observables INTEGER , INTENT ( IN ) :: alg_dim !! Dimension of State-Vector INTEGER , INTENT ( IN ) :: params_dim !! Dimension of Parameter-Vector DOUBLE PRECISION , DIMENSION ( params_dim ), INTENT ( IN ) :: params !! Parameter Vector DOUBLE PRECISION , DIMENSION ( alg_dim ), INTENT ( IN ) :: y !! State-Vector DOUBLE PRECISION , DIMENSION ( alg_dim ) :: dydt !! 1st Derivative of State-Vector ! Conversion factor for acceleration DOUBLE PRECISION , PARAMETER :: conversion = 1E9 ! Resolve params (Individually) DOUBLE PRECISION :: f_x DOUBLE PRECISION :: f_y DOUBLE PRECISION :: f_z DOUBLE PRECISION :: mass ! Force in [µN] and Mass in [fg] f_x = params ( 1 ) f_y = params ( 2 ) f_z = params ( 3 ) mass = params ( 4 ) dydt ( 1 : alg_dim / 2 ) = y ( alg_dim / 2 + 1 :) dydt ( alg_dim / 2 + 1 :) = ( / f_x / mass * conversion , f_y / mass * conversion , f_z / mass * conversion / ) END FUNCTION END MODULE module_movement","tags":"","loc":"sourcefile/module_movement.f90.html"},{"title":"particle_simulation.f90 – Fortran Program","text":"Contents Modules particle_simulation Source Code particle_simulation.f90 Source Code MODULE particle_simulation !! Main Interface to manage relevant simulation routines USE module_parameters USE module_particle USE module_init USE module_evaporation USE module_movement USE numeric_integration USE omp_lib IMPLICIT NONE PUBLIC :: initialize PUBLIC :: update PUBLIC :: output ! List of particles in simulation TYPE ( particle ), DIMENSION (:), ALLOCATABLE :: particles CONTAINS ! Source: https://www.rosenfluh.ch/ansteckungsrisiken-durch-aerosole SUBROUTINE initialize ( concentration , velocity , T_environment , humidity , v_wind ) !! Initialize list of particles INTEGER , INTENT ( IN ) :: concentration !! Particle concentration in the air [x/m³] (0...30.000) DOUBLE PRECISION , DIMENSION ( dim ), INTENT ( IN ) :: velocity !! Intensity coefficient [%] (0...1) DOUBLE PRECISION , DIMENSION ( dim ), INTENT ( IN ) :: v_wind !! Velocity of Wind [m/s] DOUBLE PRECISION , INTENT ( IN ) :: T_environment !! Temperature of environment [K] DOUBLE PRECISION , INTENT ( IN ) :: humidity !! Relative Humidity in environment [%] INTEGER :: idx ! Allocate particles list ALLOCATE ( particles ( concentration )) !$omp PARALLEL DO, NUM_THREADS(MAX) do idx = 1 , concentration call initialize_position ( particles ( idx )) call initialize_velocity ( particles ( idx ), velocity ) call initialize_structure ( particles ( idx )) call initialize_circumstances ( particles ( idx ), T_environment , humidity , v_wind ) end do !$omp END PARALLEL DO END SUBROUTINE SUBROUTINE update ( integration_procedure_evaporation , integration_procedure_movement , t_total , all_done , timestamp , breakpoint ) !! Update Particle (Single Iteration Step) PROCEDURE ( num_int_procedure ) :: integration_procedure_evaporation !! Desired numeric integration procedure for evaporation (Euler, Runge-Kutta, ...) PROCEDURE ( num_int_procedure ) :: integration_procedure_movement !! Desired numeric integration procedure for movement (Euler, Runge-Kutta, ...) DOUBLE PRECISION , INTENT ( IN ) :: t_total !! Total Runtime [s] DOUBLE PRECISION , INTENT ( IN ) :: timestamp !! Timestamp [s] LOGICAL , INTENT ( INOUT ) :: all_done !! Indicate if all particles are done LOGICAL , INTENT ( INOUT ) :: breakpoint !! Indicate if time breakpoint is reached ! Local Variables INTEGER :: num_of_particles INTEGER :: num_of_inactive INTEGER :: idx num_of_particles = SIZE ( particles , DIM = 1 ) all_done = . FALSE . num_of_inactive = 0 !$omp PARALLEL DO NUM_THREADS(MAX) do idx = 1 , num_of_particles IF ( particles ( idx )% time_elapsed . LE . timestamp ) THEN call evaluate_movement ( integration_procedure_movement , particles ( idx ), t_total ) call evaluate_evaporation ( integration_procedure_evaporation , particles ( idx )) particles ( idx )% time_elapsed = particles ( idx )% time_elapsed + particles ( idx )% dt ELSE num_of_inactive = num_of_inactive + 1 END IF end do !$omp END PARALLEL DO IF ( num_of_inactive . EQ . num_of_particles ) THEN breakpoint = . TRUE . ELSE breakpoint = . FALSE . END IF IF ( particles ( 1 )% time_elapsed . GE . t_total . AND . breakpoint . EQV . . TRUE .) THEN all_done = . TRUE . END IF END SUBROUTINE FUNCTION output ( start_idx , end_idx ) !! Form Output Data Array INTEGER , INTENT ( IN ) :: start_idx !! Start Index (Particle) INTEGER , INTENT ( IN ) :: end_idx !! End Index (Particle) ! Number of output features INTEGER , PARAMETER :: num_of_properties = 23 DOUBLE PRECISION , DIMENSION ( end_idx - start_idx + 1 , num_of_properties ) :: output !! Output Data Array INTEGER :: idx_particles , idx_array !$omp PARALLEL DO NUM_THREADS(MAX) do idx_particles = start_idx , end_idx ! Adapt indexing idx_array = idx_particles - start_idx + 1 ! General information (index and elapsed time) output ( idx_array , 1 ) = idx_particles output ( idx_array , 2 ) = particles ( idx_particles )% time_elapsed ! Output position output ( idx_array , 3 ) = particles ( idx_particles )% r ( 1 ) output ( idx_array , 4 ) = particles ( idx_particles )% r ( 2 ) output ( idx_array , 5 ) = particles ( idx_particles )% r ( 3 ) ! Output velocity output ( idx_array , 6 ) = particles ( idx_particles )% v ( 1 ) output ( idx_array , 7 ) = particles ( idx_particles )% v ( 2 ) output ( idx_array , 8 ) = particles ( idx_particles )% v ( 3 ) ! Output diameters output ( idx_array , 9 ) = particles ( idx_particles )% d_core output ( idx_array , 10 ) = particles ( idx_particles )% d_shell ! Output circumstances output ( idx_array , 11 ) = particles ( idx_particles )% T output ( idx_array , 12 ) = particles ( idx_particles )% T_environment output ( idx_array , 13 ) = particles ( idx_particles )% humidity output ( idx_array , 14 ) = particles ( idx_particles )% v_wind ( 1 ) output ( idx_array , 15 ) = particles ( idx_particles )% v_wind ( 2 ) output ( idx_array , 16 ) = particles ( idx_particles )% v_wind ( 3 ) ! Output mass output ( idx_array , 17 ) = mass_core ( particles ( idx_particles )) output ( idx_array , 18 ) = mass_shell ( particles ( idx_particles )) ! Output acting force output ( idx_array , 19 ) = particles ( idx_particles )% f ( 1 ) output ( idx_array , 20 ) = particles ( idx_particles )% f ( 2 ) output ( idx_array , 21 ) = particles ( idx_particles )% f ( 3 ) ! Output status variables output ( idx_array , 22 ) = MERGE ( 1.d0 , 0.d0 , particles ( idx_particles )% core_only ) output ( idx_array , 23 ) = MERGE ( 1.d0 , 0.d0 , particles ( idx_particles )% active ) end do !$omp END PARALLEL DO END FUNCTION END MODULE particle_simulation","tags":"","loc":"sourcefile/particle_simulation.f90.html"},{"title":"numeric_integration.f90 – Fortran Program","text":"Contents Modules numeric_integration Source Code numeric_integration.f90 Source Code MODULE numeric_integration !! Generic Implementation of numerical integration procedures IMPLICIT NONE INTERFACE FUNCTION func ( y , params , params_dim , alg_dim ) result ( dydx ) !! Generic Function Interface INTEGER , INTENT ( IN ) :: alg_dim !! Dimension of State-Vector INTEGER , INTENT ( IN ) :: params_dim !! Dimension of Parameter-Vector DOUBLE PRECISION , DIMENSION ( params_dim ), INTENT ( IN ) :: params !! Parameter Vector DOUBLE PRECISION , DIMENSION ( alg_dim ), INTENT ( IN ) :: y !! State-Vector DOUBLE PRECISION , DIMENSION ( alg_dim ) :: dydx !! 1st Derivative of State-Vector END FUNCTION SUBROUTINE num_int_procedure ( f , y , dt , params , params_dim , alg_dim ) !! Generic Numeric Integration Procedure Interface IMPORT :: func PROCEDURE ( func ) :: f !! Generic Function that is used in integration procedure INTEGER , INTENT ( IN ) :: alg_dim !! Dimension of State-Vector INTEGER , INTENT ( IN ) :: params_dim !! Dimension of Parameter-Vector DOUBLE PRECISION , INTENT ( IN ) :: dt !! Stepwidth DOUBLE PRECISION , DIMENSION ( params_dim ), INTENT ( IN ) :: params !! Parameter Vector DOUBLE PRECISION , DIMENSION ( alg_dim ), INTENT ( INOUT ) :: y !! State Vector END SUBROUTINE END INTERFACE CONTAINS SUBROUTINE runge_kutta_2k ( f , y , dt , params , params_dim , alg_dim ) !! Runge Kutta Calculation (2nd Order) ! Dummy Arguments PROCEDURE ( func ) :: f !! Generic Function that is used in integration procedure INTEGER , INTENT ( IN ) :: alg_dim !! Dimension of State-Vector INTEGER , INTENT ( IN ) :: params_dim !! Dimension of Parameter-Vector DOUBLE PRECISION , INTENT ( IN ) :: dt !! Stepwidth DOUBLE PRECISION , DIMENSION ( params_dim ), INTENT ( IN ) :: params !! Parameter Vector DOUBLE PRECISION , DIMENSION ( alg_dim ), INTENT ( INOUT ) :: y !! State Vector ! Local Variables DOUBLE PRECISION , DIMENSION ( alg_dim ) :: k1 , k2 ! Runge Kutta Algorithm (2nd Order) k1 = dt * f ( y , params , params_dim , alg_dim ) k2 = dt * f ( y + k1 / 2 , params , params_dim , alg_dim ) ! Final Value y = y + k2 END SUBROUTINE SUBROUTINE runge_kutta_4k ( f , y , dt , params , params_dim , alg_dim ) !! Runge Kutta Calculation (4th Order) ! Dummy Arguments PROCEDURE ( func ) :: f !! Generic Function that is used in integration procedure INTEGER , INTENT ( IN ) :: alg_dim !! Dimension of State-Vector INTEGER , INTENT ( IN ) :: params_dim !! Dimension of Parameter-Vector DOUBLE PRECISION , INTENT ( IN ) :: dt !! Stepwidth DOUBLE PRECISION , DIMENSION ( params_dim ), INTENT ( IN ) :: params !! Parameter Vector DOUBLE PRECISION , DIMENSION ( alg_dim ), INTENT ( INOUT ) :: y !! State Vector ! Local Variables DOUBLE PRECISION , DIMENSION ( alg_dim ) :: k1 , k2 , k3 , k4 ! Runge Kutta Algorithm (4th Order) k1 = dt * f ( y , params , params_dim , alg_dim ) k2 = dt * f ( y + k1 / 2 , params , params_dim , alg_dim ) k3 = dt * f ( y + k2 / 2 , params , params_dim , alg_dim ) k4 = dt * f ( y + k3 , params , params_dim , alg_dim ) ! Final Value y = y + ( k1 + 2 * ( k2 + k3 ) + k4 ) / 6 END SUBROUTINE SUBROUTINE euler ( f , y , dt , params , params_dim , alg_dim ) !! Euler Routine (Explicit) ! Dummy Arguments PROCEDURE ( func ) :: f !! Generic Function that is used in integration procedure INTEGER , INTENT ( IN ) :: alg_dim !! Dimension of State-Vector INTEGER , INTENT ( IN ) :: params_dim !! Dimension of Parameter-Vector DOUBLE PRECISION , INTENT ( IN ) :: dt !! Stepwidth DOUBLE PRECISION , DIMENSION ( params_dim ), INTENT ( IN ) :: params !! Parameter Vector DOUBLE PRECISION , DIMENSION ( alg_dim ), INTENT ( INOUT ) :: y !! State Vector ! Euler Algorithm (Explicit) y = y + dt * f ( y , params , params_dim , alg_dim ) END SUBROUTINE END MODULE numeric_integration","tags":"","loc":"sourcefile/numeric_integration.f90.html"},{"title":"module_init.f90 – Fortran Program","text":"Contents Modules module_init Source Code module_init.f90 Source Code MODULE module_init !! Semi-Automatic Initialization of Particles USE module_particle IMPLICIT NONE PUBLIC :: initialize_circumstances PUBLIC :: initialize_position PUBLIC :: initialize_velocity PUBLIC :: initialize_structure CONTAINS ! Initialize position of particles SUBROUTINE initialize_position ( prtcl ) ! Desired particle TYPE ( particle ), INTENT ( INOUT ) :: prtcl DOUBLE PRECISION :: buffer buffer = 0.d0 ! x-Direction [-0.5...0.5] call RANDOM_NUMBER ( buffer ) prtcl % r ( 1 ) = ( buffer - 0.5 ) ! y-Direction [-0.5...0.5] call RANDOM_NUMBER ( buffer ) prtcl % r ( 2 ) = ( buffer - 0.5 ) ! z-Direction [1...2] call RANDOM_NUMBER ( buffer ) prtcl % r ( 3 ) = ( buffer + 1 ) ! Activate Particle prtcl % active = . TRUE . END SUBROUTINE ! Initialize velocity of particles SUBROUTINE initialize_velocity ( prtcl , velocity ) ! Desired particle TYPE ( particle ), INTENT ( INOUT ) :: prtcl ! Direction coefficient [0...1] DOUBLE PRECISION , DIMENSION ( dim ), INTENT ( IN ) :: velocity prtcl % v ( 1 ) = velocity ( 1 ) prtcl % v ( 2 ) = velocity ( 2 ) prtcl % v ( 3 ) = velocity ( 3 ) END SUBROUTINE ! Initialize structure of particle ! Source: https://www.umweltbundesamt.de/themen/gesundheit/umwelteinfluesse-auf-den-menschen/innenraumluft/infektioese-aerosole-in-innenraeumen#was-sind-aerosole- SUBROUTINE initialize_structure ( prtcl ) ! Desired particle TYPE ( particle ), INTENT ( INOUT ) :: prtcl ! Conversion factor [nm to mm] DOUBLE PRECISION , PARAMETER :: conversion = 1E-3 DOUBLE PRECISION :: buffer ! Assign diameter of core [50nm...100.000nm = 100µm] and convert to [µm] call RANDOM_NUMBER ( buffer ) prtcl % d_core = ( 50 + 99950 * buffer ) * conversion ! Assign diameter of shell (water) 10% of core and convert to [µm] prtcl % d_shell = prtcl % d_core * 1.1 ! Assign temperature of particle [between 20 and 35 °C] and convert to [K] call RANDOM_NUMBER ( buffer ) prtcl % T = T_0 + 20 + 15 * buffer END SUBROUTINE ! Initialize Particle Circumstances SUBROUTINE initialize_circumstances ( prtcl , T_environment , humidity , v_wind ) ! Desired particle TYPE ( particle ), INTENT ( INOUT ) :: prtcl ! Velocity of Wind [m/s] DOUBLE PRECISION , DIMENSION ( dim ) :: v_wind ! Temperature of environment [K] DOUBLE PRECISION :: T_environment ! Relative Humidity in environment [%] DOUBLE PRECISION :: humidity ! Assign values prtcl % v_wind = v_wind prtcl % T_environment = T_environment prtcl % humidity = humidity prtcl % time_elapsed = 0 prtcl % f = 0 END SUBROUTINE END MODULE module_init","tags":"","loc":"sourcefile/module_init.f90.html"},{"title":"module_evaporation.f90 – Fortran Program","text":"Contents Modules module_evaporation Source Code module_evaporation.f90 Source Code MODULE module_evaporation !! Calculate Evaporation of Particle Shell USE module_parameters USE module_particle USE numeric_integration IMPLICIT NONE PUBLIC :: evaluate_evaporation PRIVATE :: D_Coeff PRIVATE :: p0_H2O PRIVATE :: pw_H2O PRIVATE :: pinf_H2O PRIVATE :: Sh PRIVATE :: Sc PRIVATE :: Re PRIVATE :: h_m PRIVATE :: dddt CONTAINS SUBROUTINE evaluate_evaporation ( numeric_integration_procedure , prtcl ) !! Update Particle Diameter [µm] PROCEDURE ( num_int_procedure ) :: numeric_integration_procedure !! Desired numeric integration procedure (Euler, Runge-Kutta, ...) TYPE ( particle ), INTENT ( INOUT ) :: prtcl !! Desired particle ! Key Value DOUBLE PRECISION , DIMENSION ( 1 ) :: y ! Parameter Array for Function Arguments DOUBLE PRECISION , DIMENSION ( 4 ) :: params ! Execute only if particle shell is still present IF ( prtcl % core_only . eqv . . FALSE .) THEN ! Prepare function arguments ! print *,\"shell: \",prtcl%d_shell y ( 1 ) = prtcl % d_shell params ( 1 ) = prtcl % T params ( 2 ) = prtcl % T_environment params ( 3 ) = v_euclid ( prtcl ) params ( 4 ) = prtcl % humidity ! Update Key Value call numeric_integration_procedure ( dddt , y , prtcl % dt , params , SIZE ( params , DIM = 1 ), SIZE ( y , DIM = 1 )) ! Store Changes prtcl % d_shell = y ( 1 ) ! Verify if particle shell is still present call verify_shell ( prtcl ) END IF END SUBROUTINE FUNCTION D_Coeff ( T_particle , T_environment ) !! Diffusion Coefficient [m²/s = = µm²/s * 10¹²] DOUBLE PRECISION , INTENT ( IN ) :: T_particle , T_environment !! Temperature of Particle T_prtcl and Environment T_env [K] DOUBLE PRECISION :: T_m !! Mean Temperature T_m [K] DOUBLE PRECISION :: D_Coeff !! Result (Diffusion Coefficient) [m²/s] ! Computation T_m = ( T_particle + T_environment ) / 2 D_Coeff = D_0 * ( T_m / T_0 ) ** 1.8 END FUNCTION FUNCTION p0_H2O ( T ) !! Calculate partial pressure of H2O [Pa = kg⋅m⁻¹⋅s⁻²] DOUBLE PRECISION , INTENT ( IN ) :: T !! Desired Temperature [K] ! Resulting partial pressure of H2O [Pa] DOUBLE PRECISION :: p0_H2O ! Antoine Equation (Result needs to be converted from mmHg to Pa) [Pa = kg⋅m⁻¹⋅s⁻²] p0_H2O = 10 ** ( A - B / ( C + T )) * mmHg_Pa_conversion END FUNCTION FUNCTION pw_H2O ( T_particle ) !! Calculate partial pressure of H2O in particle (fluid water) [Pa = kg⋅m⁻¹⋅s⁻²] DOUBLE PRECISION , INTENT ( IN ) :: T_particle !! Temperature of particle [K] ! Partial Pressure of fluid water [Pa] DOUBLE PRECISION :: pw_H2O ! Calculation pw_H2O = p0_H2O ( T_particle ) END FUNCTION FUNCTION pinf_H2O ( T_environment , humidity ) !! Calculate partial pressure of H2O in environment (steam) [Pa = kg⋅m⁻¹⋅s⁻²] DOUBLE PRECISION , INTENT ( IN ) :: T_environment !! Temperature of Environment [K] DOUBLE PRECISION , INTENT ( IN ) :: humidity !! Humidity of environment [%] ! Partial Pressure of H2O in environment [Pa] DOUBLE PRECISION :: pinf_H2O ! Calculation pinf_H2O = humidity * p0_H2O ( T_environment ) END FUNCTION FUNCTION Sh ( velocity , diameter , T_environment , T_particle ) !! Calculate Sherwood number [dimensionless] DOUBLE PRECISION , INTENT ( IN ) :: T_environment , T_particle !! Temperature of environment and particle [K] DOUBLE PRECISION , INTENT ( IN ) :: velocity !! Velocity of particle [m/s] DOUBLE PRECISION , INTENT ( IN ) :: diameter !! Diameter of particle [µm] ! Sherwood number DOUBLE PRECISION :: Sh ! Froessling Equation Sh = 2 + 0.552 * Re ( velocity , diameter , T_environment ) ** ( 0.5 ) * Sc ( T_environment , T_particle ) ** ( 0.33 ) END FUNCTION FUNCTION Re ( velocity , diameter , T_environment ) !! Calculate Reynolds number [dimensionless] DOUBLE PRECISION , INTENT ( IN ) :: velocity !! Velocity of particle [m/s] DOUBLE PRECISION , INTENT ( IN ) :: diameter !! Diameter of particle [µm] DOUBLE PRECISION , INTENT ( IN ) :: T_environment !! Temperature of environment and particle [K] ! Reynolds number DOUBLE PRECISION :: Re ! Conversion Factor (m to µm) DOUBLE PRECISION , PARAMETER :: conversion = 1E-6 ! Reynolds Equation Re = velocity / nu_air ( T_environment ) * diameter * conversion END FUNCTION FUNCTION Sc ( T_environment , T_particle ) !! Calculate Schmidt number [dimensionless] DOUBLE PRECISION , INTENT ( IN ) :: T_environment , T_particle !! Temperature of environment and particle [K] ! Schmidt number DOUBLE PRECISION :: Sc ! Froessling Equation Sc = nu_air ( T_environment ) / D_Coeff ( T_particle , T_environment ) END FUNCTION FUNCTION h_m ( diameter , T_environment , T_particle , velocity ) !! Calculate mass transfer coefficient [µm/s] DOUBLE PRECISION , INTENT ( IN ) :: T_environment , T_particle !! Temperature of environment and particle [K] DOUBLE PRECISION , INTENT ( IN ) :: velocity !! Velocity of particle [m/s] DOUBLE PRECISION , INTENT ( IN ) :: diameter !! Diameter of particle [µm] ! Mass Transfer Coefficient [µm/s] DOUBLE PRECISION :: h_m ! Conversion Factor (m to µm) DOUBLE PRECISION , PARAMETER :: conversion = 1E12 h_m = D_Coeff ( T_particle , T_environment ) / diameter * Sh ( velocity , diameter , T_environment , T_particle ) * conversion END FUNCTION FUNCTION dddt ( y , params , params_dim , alg_dim ) !! Calculate 1st Order Derivative of particle diameter [µm/s] INTEGER , INTENT ( IN ) :: alg_dim !! Dimension of State-Vector INTEGER , INTENT ( IN ) :: params_dim !! Dimension of Parameter-Vector DOUBLE PRECISION , DIMENSION ( params_dim ), INTENT ( IN ) :: params !! Parameter Vector DOUBLE PRECISION , DIMENSION ( alg_dim ), INTENT ( IN ) :: y !! State-Vector DOUBLE PRECISION , DIMENSION ( alg_dim ) :: dddt !! 1st Derivative of State-Vector ! Resolve params DOUBLE PRECISION :: T_particle DOUBLE PRECISION :: T_environment DOUBLE PRECISION :: velocity DOUBLE PRECISION :: humidity T_particle = params ( 1 ) T_environment = params ( 2 ) velocity = params ( 3 ) humidity = params ( 4 ) ! Calculation dddt ( 1 ) = - 2 / ( rho_H20 ) * h_m ( y ( 1 ), T_environment , T_particle , velocity ) * M_H2O / R * ( pw_H2O ( T_particle ) / T_particle & - pinf_H2O ( T_environment , humidity ) / T_environment ) END FUNCTION END MODULE module_evaporation","tags":"","loc":"sourcefile/module_evaporation.f90.html"},{"title":"module_particle.f90 – Fortran Program","text":"Contents Modules module_particle Source Code module_particle.f90 Source Code MODULE module_particle !! Define custom datatype \"particle\" USE module_parameters IMPLICIT NONE PUBLIC :: v_euclid PUBLIC :: mass_shell PUBLIC :: mass_core PUBLIC :: verify_status PUBLIC :: verify_shell PUBLIC :: set_dt PRIVATE :: vol_core PRIVATE :: vol_shell TYPE particle !! Custom Datatype for Particle-Simulation DOUBLE PRECISION , DIMENSION ( dim ) :: r !! Current Position [m] DOUBLE PRECISION , DIMENSION ( dim ) :: v !! Current Velocity [m/s] DOUBLE PRECISION , DIMENSION ( dim ) :: f !! Current Force [µN = µg·m/s] DOUBLE PRECISION :: d_core !! Particle Core Data (d = diameter [µm]) DOUBLE PRECISION :: d_shell !! Particle Shell Data (d = diameter [µm]) DOUBLE PRECISION :: T !! Temperature of particle [K] DOUBLE PRECISION :: time_elapsed !! Elapsed time [s] LOGICAL :: core_only !! Indicates if particle-shell is evaporated LOGICAL :: active !! Indicates if particle is still in the air DOUBLE PRECISION , DIMENSION ( dim ) :: v_wind !! Velocity of Wind [m/s] DOUBLE PRECISION :: T_environment !! Temperature of environment [K] DOUBLE PRECISION :: humidity !! Relative Humidity in environment [%] DOUBLE PRECISION :: dt !! Current Stepwidth [s] END TYPE particle CONTAINS FUNCTION v_euclid ( prtcl ) !! Euclidic norm of velocity of particle TYPE ( particle ), INTENT ( IN ) :: prtcl !! Desired particle ! Euclidic norm of velocity of particle [m/s] DOUBLE PRECISION :: v_euclid ! Calculation v_euclid = abs ( sqrt ( sum ( prtcl % v ** 2 ))) END FUNCTION FUNCTION mass_core ( prtcl ) !! Get mass of particle core [fg = femtogramm] TYPE ( particle ), INTENT ( IN ) :: prtcl !! Desired particle ! Mass of particle [fg] DOUBLE PRECISION :: mass_core ! Calculation mass_core = vol_core ( prtcl ) * rho_cov2 END FUNCTION FUNCTION vol_core ( prtcl ) !! Get volume of particle core [µm³] TYPE ( particle ), INTENT ( IN ) :: prtcl !! Desired particle ! Volume of particle core [µm³] DOUBLE PRECISION :: vol_core ! Calculation vol_core = ( prtcl % d_core / 2 ) ** 3 * PI * 4 / 3 END FUNCTION FUNCTION mass_shell ( prtcl ) !! Get mass of particle shell [fg = femtogramm] TYPE ( particle ), INTENT ( IN ) :: prtcl !! Desired particle ! Mass of particle shell [fg] DOUBLE PRECISION :: mass_shell ! Calculation mass_shell = vol_shell ( prtcl ) * rho_H20 END FUNCTION FUNCTION vol_shell ( prtcl ) !!Get volume of particle shell [µm³] TYPE ( particle ), INTENT ( IN ) :: prtcl !! Desired particle ! Volume of particle shell [µm³] DOUBLE PRECISION :: vol_shell ! Calculation vol_shell = (( prtcl % d_shell / 2 ) ** 3 - ( prtcl % d_core / 2 ) ** 3 ) * PI * 4 / 3 END FUNCTION SUBROUTINE verify_shell ( prtcl ) !! Verify if particle shell is completely evaporated TYPE ( particle ), INTENT ( INOUT ) :: prtcl !! Desired particle ! Check if shell diameter is less or equal to certain threshold (hard-coded: 1%) of core diameter IF ( prtcl % d_shell . le . 1.01 * prtcl % d_core ) THEN prtcl % core_only = . TRUE . prtcl % d_shell = prtcl % d_core ELSE prtcl % core_only = . FALSE . END IF END SUBROUTINE SUBROUTINE verify_status ( prtcl , t_total ) !! Verify if particle is still active TYPE ( particle ), INTENT ( INOUT ) :: prtcl !! Desired particle DOUBLE PRECISION , INTENT ( IN ) :: t_total !! Total Simulaiton Time ! Check if z-coordinate is less or equal to 0 (ground-level) IF ( prtcl % r ( 3 ) . le . 0.d0 ) THEN prtcl % active = . FALSE . prtcl % r ( 3 ) = 0 ELSE IF ( prtcl % time_elapsed . ge . t_total ) THEN prtcl % active = . FALSE . ELSE prtcl % active = . TRUE . END IF END SUBROUTINE SUBROUTINE set_dt ( prtcl , f_r ) !! Set current stepwidth [s] TYPE ( particle ), INTENT ( INOUT ) :: prtcl !! Desired Particle DOUBLE PRECISION , INTENT ( IN ) :: f_r !! Air resistance force [µN] ! Max change of acceleration [m/s] DOUBLE PRECISION , PARAMETER :: boundary = 5E-4 ! Conversion Factor DOUBLE PRECISION , PARAMETER :: conversion1 = 1E-9 ! Conversion Factor DOUBLE PRECISION , PARAMETER :: conversion2 = 1E-6 ! Default Value DOUBLE PRECISION , PARAMETER :: default = 1E-3 ! Local parameters DOUBLE PRECISION :: dt1 , dt2 dt1 = boundary * ( mass_core ( prtcl ) + mass_shell ( prtcl )) / f_r * conversion1 dt2 = prtcl % d_shell / ( 200 * v_euclid ( prtcl )) * conversion2 IF ( dt1 . ge . dt2 ) THEN prtcl % dt = dt2 ELSE prtcl % dt = dt1 END IF IF ( prtcl % dt . GT . 1 ) prtcl % dt = default END SUBROUTINE END MODULE module_particle","tags":"","loc":"sourcefile/module_particle.f90.html"},{"title":"particle – Fortran Program ","text":"type, public :: particle Custom Datatype for Particle-Simulation Contents Variables r v f d_core d_shell T time_elapsed core_only active v_wind T_environment humidity dt Components Type Visibility Attributes Name Initial double precision, public, DIMENSION(dim) :: r Current Position [m] double precision, public, DIMENSION(dim) :: v Current Velocity [m/s] double precision, public, DIMENSION(dim) :: f Current Force [µN = µg·m/s] double precision, public :: d_core Particle Core Data (d = diameter [µm]) double precision, public :: d_shell Particle Shell Data (d = diameter [µm]) double precision, public :: T Temperature of particle [K] double precision, public :: time_elapsed Elapsed time [s] logical, public :: core_only Indicates if particle-shell is evaporated logical, public :: active Indicates if particle is still in the air double precision, public, DIMENSION(dim) :: v_wind Velocity of Wind [m/s] double precision, public :: T_environment Temperature of environment [K] double precision, public :: humidity Relative Humidity in environment [%] double precision, public :: dt Current Stepwidth [s]","tags":"","loc":"type/particle.html"},{"title":"rho_air – Fortran Program","text":"public function rho_air(T_environment) Arguments Type Intent Optional Attributes Name double precision, intent(in) :: T_environment Return Value double precision Contents None","tags":"","loc":"proc/rho_air.html"},{"title":"nu_air – Fortran Program","text":"public function nu_air(T_environment) Arguments Type Intent Optional Attributes Name double precision, intent(in) :: T_environment Return Value double precision Contents None","tags":"","loc":"proc/nu_air.html"},{"title":"etha_air – Fortran Program","text":"public function etha_air(T_environment) Arguments Type Intent Optional Attributes Name double precision, intent(in) :: T_environment Return Value double precision Contents None","tags":"","loc":"proc/etha_air.html"},{"title":"evaluate_force – Fortran Program","text":"public subroutine evaluate_force(prtcl) Update Acting Force on Particle (required in each step) [µN = µg*m/s²] Arguments Type Intent Optional Attributes Name type( particle ), intent(inout) :: prtcl Desired particle Contents None","tags":"","loc":"proc/evaluate_force.html"},{"title":"reset – Fortran Program","text":"private subroutine reset(prtcl) Arguments Type Intent Optional Attributes Name type( particle ), intent(inout) :: prtcl Contents None","tags":"","loc":"proc/reset.html"},{"title":"gravitation – Fortran Program","text":"private subroutine gravitation(prtcl) Calculate gravitational force [µN = µg*m/s²] Arguments Type Intent Optional Attributes Name type( particle ), intent(inout) :: prtcl Desired particle Contents None","tags":"","loc":"proc/gravitation.html"},{"title":"air_resistance – Fortran Program","text":"private subroutine air_resistance(prtcl) Calculate air resistance force [µN = µg*m/s²] Arguments Type Intent Optional Attributes Name type( particle ), intent(inout) :: prtcl Desired particle Contents None","tags":"","loc":"proc/air_resistance.html"},{"title":"wind – Fortran Program","text":"private subroutine wind(prtcl) Calculate wind force [µN = µg*m/s²] Arguments Type Intent Optional Attributes Name type( particle ), intent(inout) :: prtcl Desired particle Contents None","tags":"","loc":"proc/wind.html"},{"title":"read_config – Fortran Program","text":"subroutine read_config(filename) Read in parameter configuration from file Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename Filename Contents None","tags":"","loc":"proc/read_config.html"},{"title":"write_to_file – Fortran Program","text":"subroutine write_to_file(filename_base, n_current) Write data to file Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename_base File-Basename integer, intent(in) :: n_current Current iteration number Contents None","tags":"","loc":"proc/write_to_file.html"},{"title":"print_output – Fortran Program","text":"subroutine print_output(array) Print array to console Arguments Type Intent Optional Attributes Name double precision, intent(in), DIMENSION(concentration, num_of_variables) :: array Desired Array Contents None","tags":"","loc":"proc/print_output.html"},{"title":"dydt – Fortran Program","text":"private function dydt(y, params, params_dim, alg_dim) 1st order Derivative of State-Observables Arguments Type Intent Optional Attributes Name double precision, intent(in), DIMENSION(alg_dim) :: y State-Vector double precision, intent(in), DIMENSION(params_dim) :: params Parameter Vector integer, intent(in) :: params_dim Dimension of Parameter-Vector integer, intent(in) :: alg_dim Dimension of State-Vector Return Value double precision,\n  DIMENSION(alg_dim) 1st Derivative of State-Vector Contents None","tags":"","loc":"proc/dydt.html"},{"title":"evaluate_movement – Fortran Program","text":"public subroutine evaluate_movement(numeric_integration_procedure, prtcl, t_total) Update Particle Movement [location: m, velocity: m/s, acceleration: m/s²] Arguments Type Intent Optional Attributes Name procedure( num_int_procedure ) :: numeric_integration_procedure Desired numeric integration procedure (Euler, Runge-Kutta, ...) type( particle ), intent(inout) :: prtcl Desired particle double precision, intent(in) :: t_total Indicate if all particles are simulated Contents None","tags":"","loc":"proc/evaluate_movement.html"},{"title":"output – Fortran Program","text":"public function output(start_idx, end_idx) Form Output Data Array Arguments Type Intent Optional Attributes Name integer, intent(in) :: start_idx Start Index (Particle) integer, intent(in) :: end_idx End Index (Particle) Return Value double precision,\n  DIMENSION(end_idx-start_idx + 1, num_of_properties) Output Data Array Contents None","tags":"","loc":"proc/output.html"},{"title":"initialize – Fortran Program","text":"public subroutine initialize(concentration, velocity, T_environment, humidity, v_wind) Initialize list of particles Arguments Type Intent Optional Attributes Name integer, intent(in) :: concentration Particle concentration in the air [x/m³] (0...30.000) double precision, intent(in), DIMENSION(dim) :: velocity Intensity coefficient [%] (0...1) double precision, intent(in) :: T_environment Temperature of environment [K] double precision, intent(in) :: humidity Relative Humidity in environment [%] double precision, intent(in), DIMENSION(dim) :: v_wind Velocity of Wind [m/s] Contents None","tags":"","loc":"proc/initialize.html"},{"title":"update – Fortran Program","text":"public subroutine update(integration_procedure_evaporation, integration_procedure_movement, t_total, all_done, timestamp, breakpoint) Update Particle (Single Iteration Step) Arguments Type Intent Optional Attributes Name procedure( num_int_procedure ) :: integration_procedure_evaporation Desired numeric integration procedure for evaporation (Euler, Runge-Kutta, ...) procedure( num_int_procedure ) :: integration_procedure_movement Desired numeric integration procedure for movement (Euler, Runge-Kutta, ...) double precision, intent(in) :: t_total Total Runtime [s] logical, intent(inout) :: all_done Indicate if all particles are done double precision, intent(in) :: timestamp Timestamp [s] logical, intent(inout) :: breakpoint Indicate if time breakpoint is reached Contents None","tags":"","loc":"proc/update.html"},{"title":"runge_kutta_2k – Fortran Program","text":"public subroutine runge_kutta_2k(f, y, dt, params, params_dim, alg_dim) Runge Kutta Calculation (2nd Order) Arguments Type Intent Optional Attributes Name procedure( func ) :: f Generic Function that is used in integration procedure double precision, intent(inout), DIMENSION(alg_dim) :: y State Vector double precision, intent(in) :: dt Stepwidth double precision, intent(in), DIMENSION(params_dim) :: params Parameter Vector integer, intent(in) :: params_dim Dimension of Parameter-Vector integer, intent(in) :: alg_dim Dimension of State-Vector Contents None","tags":"","loc":"proc/runge_kutta_2k.html"},{"title":"runge_kutta_4k – Fortran Program","text":"public subroutine runge_kutta_4k(f, y, dt, params, params_dim, alg_dim) Runge Kutta Calculation (4th Order) Arguments Type Intent Optional Attributes Name procedure( func ) :: f Generic Function that is used in integration procedure double precision, intent(inout), DIMENSION(alg_dim) :: y State Vector double precision, intent(in) :: dt Stepwidth double precision, intent(in), DIMENSION(params_dim) :: params Parameter Vector integer, intent(in) :: params_dim Dimension of Parameter-Vector integer, intent(in) :: alg_dim Dimension of State-Vector Contents None","tags":"","loc":"proc/runge_kutta_4k.html"},{"title":"euler – Fortran Program","text":"public subroutine euler(f, y, dt, params, params_dim, alg_dim) Euler Routine (Explicit) Arguments Type Intent Optional Attributes Name procedure( func ) :: f Generic Function that is used in integration procedure double precision, intent(inout), DIMENSION(alg_dim) :: y State Vector double precision, intent(in) :: dt Stepwidth double precision, intent(in), DIMENSION(params_dim) :: params Parameter Vector integer, intent(in) :: params_dim Dimension of Parameter-Vector integer, intent(in) :: alg_dim Dimension of State-Vector Contents None","tags":"","loc":"proc/euler.html"},{"title":"func – Fortran Program","text":"interface public function func(y, params, params_dim, alg_dim) result(dydx) Arguments Type Intent Optional Attributes Name double precision, intent(in), DIMENSION(alg_dim) :: y State-Vector double precision, intent(in), DIMENSION(params_dim) :: params Parameter Vector integer, intent(in) :: params_dim Dimension of Parameter-Vector integer, intent(in) :: alg_dim Dimension of State-Vector Return Value double precision,\n  DIMENSION(alg_dim) 1st Derivative of State-Vector Description Generic Function Interface","tags":"","loc":"interface/func.html"},{"title":"num_int_procedure – Fortran Program","text":"interface public subroutine num_int_procedure(f, y, dt, params, params_dim, alg_dim) Arguments Type Intent Optional Attributes Name procedure( func ) :: f Generic Function that is used in integration procedure double precision, intent(inout), DIMENSION(alg_dim) :: y State Vector double precision, intent(in) :: dt Stepwidth double precision, intent(in), DIMENSION(params_dim) :: params Parameter Vector integer, intent(in) :: params_dim Dimension of Parameter-Vector integer, intent(in) :: alg_dim Dimension of State-Vector Description Generic Numeric Integration Procedure Interface","tags":"","loc":"interface/num_int_procedure.html"},{"title":"initialize_position – Fortran Program","text":"public subroutine initialize_position(prtcl) Arguments Type Intent Optional Attributes Name type( particle ), intent(inout) :: prtcl Contents None","tags":"","loc":"proc/initialize_position.html"},{"title":"initialize_velocity – Fortran Program","text":"public subroutine initialize_velocity(prtcl, velocity) Arguments Type Intent Optional Attributes Name type( particle ), intent(inout) :: prtcl double precision, intent(in), DIMENSION(dim) :: velocity Contents None","tags":"","loc":"proc/initialize_velocity.html"},{"title":"initialize_structure – Fortran Program","text":"public subroutine initialize_structure(prtcl) Arguments Type Intent Optional Attributes Name type( particle ), intent(inout) :: prtcl Contents None","tags":"","loc":"proc/initialize_structure.html"},{"title":"initialize_circumstances – Fortran Program","text":"public subroutine initialize_circumstances(prtcl, T_environment, humidity, v_wind) Arguments Type Intent Optional Attributes Name type( particle ), intent(inout) :: prtcl double precision :: T_environment double precision :: humidity double precision, DIMENSION(dim) :: v_wind Contents None","tags":"","loc":"proc/initialize_circumstances.html"},{"title":"D_Coeff – Fortran Program","text":"private function D_Coeff(T_particle, T_environment) Diffusion Coefficient [m²/s = = µm²/s * 10¹²] Arguments Type Intent Optional Attributes Name double precision, intent(in) :: T_particle Temperature of Particle T_prtcl and Environment T_env [K] double precision, intent(in) :: T_environment Temperature of Particle T_prtcl and Environment T_env [K] Return Value double precision Result (Diffusion Coefficient) [m²/s] Contents None","tags":"","loc":"proc/d_coeff.html"},{"title":"p0_H2O – Fortran Program","text":"private function p0_H2O(T) Calculate partial pressure of H2O [Pa = kg⋅m⁻¹⋅s⁻²] Arguments Type Intent Optional Attributes Name double precision, intent(in) :: T Desired Temperature [K] Return Value double precision Contents None","tags":"","loc":"proc/p0_h2o.html"},{"title":"pw_H2O – Fortran Program","text":"private function pw_H2O(T_particle) Calculate partial pressure of H2O in particle (fluid water) [Pa = kg⋅m⁻¹⋅s⁻²] Arguments Type Intent Optional Attributes Name double precision, intent(in) :: T_particle Temperature of particle [K] Return Value double precision Contents None","tags":"","loc":"proc/pw_h2o.html"},{"title":"pinf_H2O – Fortran Program","text":"private function pinf_H2O(T_environment, humidity) Calculate partial pressure of H2O in environment (steam) [Pa = kg⋅m⁻¹⋅s⁻²] Arguments Type Intent Optional Attributes Name double precision, intent(in) :: T_environment Temperature of Environment [K] double precision, intent(in) :: humidity Humidity of environment [%] Return Value double precision Contents None","tags":"","loc":"proc/pinf_h2o.html"},{"title":"Sh – Fortran Program","text":"private function Sh(velocity, diameter, T_environment, T_particle) Calculate Sherwood number [dimensionless] Arguments Type Intent Optional Attributes Name double precision, intent(in) :: velocity Velocity of particle [m/s] double precision, intent(in) :: diameter Diameter of particle [µm] double precision, intent(in) :: T_environment Temperature of environment and particle [K] double precision, intent(in) :: T_particle Temperature of environment and particle [K] Return Value double precision Contents None","tags":"","loc":"proc/sh.html"},{"title":"Re – Fortran Program","text":"private function Re(velocity, diameter, T_environment) Calculate Reynolds number [dimensionless] Arguments Type Intent Optional Attributes Name double precision, intent(in) :: velocity Velocity of particle [m/s] double precision, intent(in) :: diameter Diameter of particle [µm] double precision, intent(in) :: T_environment Temperature of environment and particle [K] Return Value double precision Contents None","tags":"","loc":"proc/re.html"},{"title":"Sc – Fortran Program","text":"private function Sc(T_environment, T_particle) Calculate Schmidt number [dimensionless] Arguments Type Intent Optional Attributes Name double precision, intent(in) :: T_environment Temperature of environment and particle [K] double precision, intent(in) :: T_particle Temperature of environment and particle [K] Return Value double precision Contents None","tags":"","loc":"proc/sc.html"},{"title":"h_m – Fortran Program","text":"private function h_m(diameter, T_environment, T_particle, velocity) Calculate mass transfer coefficient [µm/s] Arguments Type Intent Optional Attributes Name double precision, intent(in) :: diameter Diameter of particle [µm] double precision, intent(in) :: T_environment Temperature of environment and particle [K] double precision, intent(in) :: T_particle Temperature of environment and particle [K] double precision, intent(in) :: velocity Velocity of particle [m/s] Return Value double precision Contents None","tags":"","loc":"proc/h_m.html"},{"title":"dddt – Fortran Program","text":"private function dddt(y, params, params_dim, alg_dim) Calculate 1st Order Derivative of particle diameter [µm/s] Arguments Type Intent Optional Attributes Name double precision, intent(in), DIMENSION(alg_dim) :: y State-Vector double precision, intent(in), DIMENSION(params_dim) :: params Parameter Vector integer, intent(in) :: params_dim Dimension of Parameter-Vector integer, intent(in) :: alg_dim Dimension of State-Vector Return Value double precision,\n  DIMENSION(alg_dim) 1st Derivative of State-Vector Contents None","tags":"","loc":"proc/dddt.html"},{"title":"evaluate_evaporation – Fortran Program","text":"public subroutine evaluate_evaporation(numeric_integration_procedure, prtcl) Update Particle Diameter [µm] Arguments Type Intent Optional Attributes Name procedure( num_int_procedure ) :: numeric_integration_procedure Desired numeric integration procedure (Euler, Runge-Kutta, ...) type( particle ), intent(inout) :: prtcl Desired particle Contents None","tags":"","loc":"proc/evaluate_evaporation.html"},{"title":"v_euclid – Fortran Program","text":"public function v_euclid(prtcl) Euclidic norm of velocity of particle Arguments Type Intent Optional Attributes Name type( particle ), intent(in) :: prtcl Desired particle Return Value double precision Contents None","tags":"","loc":"proc/v_euclid.html"},{"title":"mass_core – Fortran Program","text":"public function mass_core(prtcl) Get mass of particle core [fg = femtogramm] Arguments Type Intent Optional Attributes Name type( particle ), intent(in) :: prtcl Desired particle Return Value double precision Contents None","tags":"","loc":"proc/mass_core.html"},{"title":"vol_core – Fortran Program","text":"private function vol_core(prtcl) Get volume of particle core [µm³] Arguments Type Intent Optional Attributes Name type( particle ), intent(in) :: prtcl Desired particle Return Value double precision Contents None","tags":"","loc":"proc/vol_core.html"},{"title":"mass_shell – Fortran Program","text":"public function mass_shell(prtcl) Get mass of particle shell [fg = femtogramm] Arguments Type Intent Optional Attributes Name type( particle ), intent(in) :: prtcl Desired particle Return Value double precision Contents None","tags":"","loc":"proc/mass_shell.html"},{"title":"vol_shell – Fortran Program","text":"private function vol_shell(prtcl) Get volume of particle shell [µm³] Arguments Type Intent Optional Attributes Name type( particle ), intent(in) :: prtcl Desired particle Return Value double precision Contents None","tags":"","loc":"proc/vol_shell.html"},{"title":"verify_shell – Fortran Program","text":"public subroutine verify_shell(prtcl) Verify if particle shell is completely evaporated Arguments Type Intent Optional Attributes Name type( particle ), intent(inout) :: prtcl Desired particle Contents None","tags":"","loc":"proc/verify_shell.html"},{"title":"verify_status – Fortran Program","text":"public subroutine verify_status(prtcl, t_total) Verify if particle is still active Arguments Type Intent Optional Attributes Name type( particle ), intent(inout) :: prtcl Desired particle double precision, intent(in) :: t_total Total Simulaiton Time Contents None","tags":"","loc":"proc/verify_status.html"},{"title":"set_dt – Fortran Program","text":"public subroutine set_dt(prtcl, f_r) Set current stepwidth [s] Arguments Type Intent Optional Attributes Name type( particle ), intent(inout) :: prtcl Desired Particle double precision, intent(in) :: f_r Air resistance force [µN] Contents None","tags":"","loc":"proc/set_dt.html"},{"title":"module_parameters – Fortran Program","text":"Define global parameters Contents Variables dim g R p_atm M_H2O M_air rho_H20 rho_cov2 D_0 T_0 A B C mmHg_Pa_conversion PI Functions rho_air nu_air etha_air Variables Type Visibility Attributes Name Initial integer, public, parameter :: dim = 3 double precision, public, DIMENSION(dim) :: g = (/0.0, 0.0, -9.80665/) double precision, public, parameter :: R = 8.31446261815324 double precision, public, parameter :: p_atm = 101325 double precision, public, parameter :: M_H2O = 18.01538*1E-3 double precision, public, parameter :: M_air = 28.9644*1E-3 double precision, public, parameter :: rho_H20 = 1000 double precision, public, parameter :: rho_cov2 = 1000 double precision, public, parameter :: D_0 = 2.3*1E-5 double precision, public, parameter :: T_0 = 273.15 double precision, public, parameter :: A = 8.07131 double precision, public, parameter :: B = 1730.63 double precision, public, parameter :: C = 233.426 double precision, public, parameter :: mmHg_Pa_conversion = 133.32 double precision, public, parameter :: PI = 4.d0*DATAN(1.d0) Functions public function rho_air (T_environment) Arguments Type Intent Optional Attributes Name double precision, intent(in) :: T_environment Return Value double precision public function nu_air (T_environment) Arguments Type Intent Optional Attributes Name double precision, intent(in) :: T_environment Return Value double precision public function etha_air (T_environment) Arguments Type Intent Optional Attributes Name double precision, intent(in) :: T_environment Return Value double precision","tags":"","loc":"module/module_parameters.html"},{"title":"module_force – Fortran Program","text":"Calculate Acting Force on Particle Uses module_parameters module_particle Contents Subroutines evaluate_force reset gravitation air_resistance wind Subroutines public subroutine evaluate_force (prtcl) Update Acting Force on Particle (required in each step) [µN = µg*m/s²] Arguments Type Intent Optional Attributes Name type( particle ), intent(inout) :: prtcl Desired particle private subroutine reset (prtcl) Arguments Type Intent Optional Attributes Name type( particle ), intent(inout) :: prtcl private subroutine gravitation (prtcl) Calculate gravitational force [µN = µg*m/s²] Arguments Type Intent Optional Attributes Name type( particle ), intent(inout) :: prtcl Desired particle private subroutine air_resistance (prtcl) Calculate air resistance force [µN = µg*m/s²] Arguments Type Intent Optional Attributes Name type( particle ), intent(inout) :: prtcl Desired particle private subroutine wind (prtcl) Calculate wind force [µN = µg*m/s²] Arguments Type Intent Optional Attributes Name type( particle ), intent(inout) :: prtcl Desired particle","tags":"","loc":"module/module_force.html"},{"title":"module_movement – Fortran Program","text":"Calculate movement of particle Uses module_parameters module_particle module_force numeric_integration Contents Functions dydt Subroutines evaluate_movement Functions private function dydt (y, params, params_dim, alg_dim) 1st order Derivative of State-Observables Arguments Type Intent Optional Attributes Name double precision, intent(in), DIMENSION(alg_dim) :: y State-Vector double precision, intent(in), DIMENSION(params_dim) :: params Parameter Vector integer, intent(in) :: params_dim Dimension of Parameter-Vector integer, intent(in) :: alg_dim Dimension of State-Vector Return Value double precision,\n  DIMENSION(alg_dim) 1st Derivative of State-Vector Subroutines public subroutine evaluate_movement (numeric_integration_procedure, prtcl, t_total) Update Particle Movement [location: m, velocity: m/s, acceleration: m/s²] Arguments Type Intent Optional Attributes Name procedure( num_int_procedure ) :: numeric_integration_procedure Desired numeric integration procedure (Euler, Runge-Kutta, ...) type( particle ), intent(inout) :: prtcl Desired particle double precision, intent(in) :: t_total Indicate if all particles are simulated","tags":"","loc":"module/module_movement.html"},{"title":"particle_simulation – Fortran Program","text":"Main Interface to manage relevant simulation routines Uses module_parameters module_particle module_init module_evaporation module_movement numeric_integration omp_lib Contents Variables particles Functions output Subroutines initialize update Variables Type Visibility Attributes Name Initial type( particle ), public, DIMENSION(:), ALLOCATABLE :: particles Functions public function output (start_idx, end_idx) Form Output Data Array Arguments Type Intent Optional Attributes Name integer, intent(in) :: start_idx Start Index (Particle) integer, intent(in) :: end_idx End Index (Particle) Return Value double precision,\n  DIMENSION(end_idx-start_idx + 1, num_of_properties) Output Data Array Subroutines public subroutine initialize (concentration, velocity, T_environment, humidity, v_wind) Initialize list of particles Arguments Type Intent Optional Attributes Name integer, intent(in) :: concentration Particle concentration in the air [x/m³] (0...30.000) double precision, intent(in), DIMENSION(dim) :: velocity Intensity coefficient [%] (0...1) double precision, intent(in) :: T_environment Temperature of environment [K] double precision, intent(in) :: humidity Relative Humidity in environment [%] double precision, intent(in), DIMENSION(dim) :: v_wind Velocity of Wind [m/s] public subroutine update (integration_procedure_evaporation, integration_procedure_movement, t_total, all_done, timestamp, breakpoint) Update Particle (Single Iteration Step) Arguments Type Intent Optional Attributes Name procedure( num_int_procedure ) :: integration_procedure_evaporation Desired numeric integration procedure for evaporation (Euler, Runge-Kutta, ...) procedure( num_int_procedure ) :: integration_procedure_movement Desired numeric integration procedure for movement (Euler, Runge-Kutta, ...) double precision, intent(in) :: t_total Total Runtime [s] logical, intent(inout) :: all_done Indicate if all particles are done double precision, intent(in) :: timestamp Timestamp [s] logical, intent(inout) :: breakpoint Indicate if time breakpoint is reached","tags":"","loc":"module/particle_simulation.html"},{"title":"numeric_integration – Fortran Program","text":"Generic Implementation of numerical integration procedures Contents Interfaces func num_int_procedure Subroutines runge_kutta_2k runge_kutta_4k euler Interfaces interface public function func(y, params, params_dim, alg_dim) result(dydx) Generic Function Interface Arguments Type Intent Optional Attributes Name double precision, intent(in), DIMENSION(alg_dim) :: y State-Vector double precision, intent(in), DIMENSION(params_dim) :: params Parameter Vector integer, intent(in) :: params_dim Dimension of Parameter-Vector integer, intent(in) :: alg_dim Dimension of State-Vector Return Value double precision,\n  DIMENSION(alg_dim) 1st Derivative of State-Vector interface public subroutine num_int_procedure(f, y, dt, params, params_dim, alg_dim) Generic Numeric Integration Procedure Interface Arguments Type Intent Optional Attributes Name procedure( func ) :: f Generic Function that is used in integration procedure double precision, intent(inout), DIMENSION(alg_dim) :: y State Vector double precision, intent(in) :: dt Stepwidth double precision, intent(in), DIMENSION(params_dim) :: params Parameter Vector integer, intent(in) :: params_dim Dimension of Parameter-Vector integer, intent(in) :: alg_dim Dimension of State-Vector Subroutines public subroutine runge_kutta_2k (f, y, dt, params, params_dim, alg_dim) Runge Kutta Calculation (2nd Order) Arguments Type Intent Optional Attributes Name procedure( func ) :: f Generic Function that is used in integration procedure double precision, intent(inout), DIMENSION(alg_dim) :: y State Vector double precision, intent(in) :: dt Stepwidth double precision, intent(in), DIMENSION(params_dim) :: params Parameter Vector integer, intent(in) :: params_dim Dimension of Parameter-Vector integer, intent(in) :: alg_dim Dimension of State-Vector public subroutine runge_kutta_4k (f, y, dt, params, params_dim, alg_dim) Runge Kutta Calculation (4th Order) Arguments Type Intent Optional Attributes Name procedure( func ) :: f Generic Function that is used in integration procedure double precision, intent(inout), DIMENSION(alg_dim) :: y State Vector double precision, intent(in) :: dt Stepwidth double precision, intent(in), DIMENSION(params_dim) :: params Parameter Vector integer, intent(in) :: params_dim Dimension of Parameter-Vector integer, intent(in) :: alg_dim Dimension of State-Vector public subroutine euler (f, y, dt, params, params_dim, alg_dim) Euler Routine (Explicit) Arguments Type Intent Optional Attributes Name procedure( func ) :: f Generic Function that is used in integration procedure double precision, intent(inout), DIMENSION(alg_dim) :: y State Vector double precision, intent(in) :: dt Stepwidth double precision, intent(in), DIMENSION(params_dim) :: params Parameter Vector integer, intent(in) :: params_dim Dimension of Parameter-Vector integer, intent(in) :: alg_dim Dimension of State-Vector","tags":"","loc":"module/numeric_integration.html"},{"title":"module_init – Fortran Program","text":"Semi-Automatic Initialization of Particles Uses module_particle Contents Subroutines initialize_position initialize_velocity initialize_structure initialize_circumstances Subroutines public subroutine initialize_position (prtcl) Arguments Type Intent Optional Attributes Name type( particle ), intent(inout) :: prtcl public subroutine initialize_velocity (prtcl, velocity) Arguments Type Intent Optional Attributes Name type( particle ), intent(inout) :: prtcl double precision, intent(in), DIMENSION(dim) :: velocity public subroutine initialize_structure (prtcl) Arguments Type Intent Optional Attributes Name type( particle ), intent(inout) :: prtcl public subroutine initialize_circumstances (prtcl, T_environment, humidity, v_wind) Arguments Type Intent Optional Attributes Name type( particle ), intent(inout) :: prtcl double precision :: T_environment double precision :: humidity double precision, DIMENSION(dim) :: v_wind","tags":"","loc":"module/module_init.html"},{"title":"module_evaporation – Fortran Program","text":"Calculate Evaporation of Particle Shell Uses module_parameters module_particle numeric_integration Contents Functions D_Coeff p0_H2O pw_H2O pinf_H2O Sh Re Sc h_m dddt Subroutines evaluate_evaporation Functions private function D_Coeff (T_particle, T_environment) Diffusion Coefficient [m²/s = = µm²/s * 10¹²] Arguments Type Intent Optional Attributes Name double precision, intent(in) :: T_particle Temperature of Particle T_prtcl and Environment T_env [K] double precision, intent(in) :: T_environment Temperature of Particle T_prtcl and Environment T_env [K] Return Value double precision Result (Diffusion Coefficient) [m²/s] private function p0_H2O (T) Calculate partial pressure of H2O [Pa = kg⋅m⁻¹⋅s⁻²] Arguments Type Intent Optional Attributes Name double precision, intent(in) :: T Desired Temperature [K] Return Value double precision private function pw_H2O (T_particle) Calculate partial pressure of H2O in particle (fluid water) [Pa = kg⋅m⁻¹⋅s⁻²] Arguments Type Intent Optional Attributes Name double precision, intent(in) :: T_particle Temperature of particle [K] Return Value double precision private function pinf_H2O (T_environment, humidity) Calculate partial pressure of H2O in environment (steam) [Pa = kg⋅m⁻¹⋅s⁻²] Arguments Type Intent Optional Attributes Name double precision, intent(in) :: T_environment Temperature of Environment [K] double precision, intent(in) :: humidity Humidity of environment [%] Return Value double precision private function Sh (velocity, diameter, T_environment, T_particle) Calculate Sherwood number [dimensionless] Arguments Type Intent Optional Attributes Name double precision, intent(in) :: velocity Velocity of particle [m/s] double precision, intent(in) :: diameter Diameter of particle [µm] double precision, intent(in) :: T_environment Temperature of environment and particle [K] double precision, intent(in) :: T_particle Temperature of environment and particle [K] Return Value double precision private function Re (velocity, diameter, T_environment) Calculate Reynolds number [dimensionless] Arguments Type Intent Optional Attributes Name double precision, intent(in) :: velocity Velocity of particle [m/s] double precision, intent(in) :: diameter Diameter of particle [µm] double precision, intent(in) :: T_environment Temperature of environment and particle [K] Return Value double precision private function Sc (T_environment, T_particle) Calculate Schmidt number [dimensionless] Arguments Type Intent Optional Attributes Name double precision, intent(in) :: T_environment Temperature of environment and particle [K] double precision, intent(in) :: T_particle Temperature of environment and particle [K] Return Value double precision private function h_m (diameter, T_environment, T_particle, velocity) Calculate mass transfer coefficient [µm/s] Arguments Type Intent Optional Attributes Name double precision, intent(in) :: diameter Diameter of particle [µm] double precision, intent(in) :: T_environment Temperature of environment and particle [K] double precision, intent(in) :: T_particle Temperature of environment and particle [K] double precision, intent(in) :: velocity Velocity of particle [m/s] Return Value double precision private function dddt (y, params, params_dim, alg_dim) Calculate 1st Order Derivative of particle diameter [µm/s] Arguments Type Intent Optional Attributes Name double precision, intent(in), DIMENSION(alg_dim) :: y State-Vector double precision, intent(in), DIMENSION(params_dim) :: params Parameter Vector integer, intent(in) :: params_dim Dimension of Parameter-Vector integer, intent(in) :: alg_dim Dimension of State-Vector Return Value double precision,\n  DIMENSION(alg_dim) 1st Derivative of State-Vector Subroutines public subroutine evaluate_evaporation (numeric_integration_procedure, prtcl) Update Particle Diameter [µm] Arguments Type Intent Optional Attributes Name procedure( num_int_procedure ) :: numeric_integration_procedure Desired numeric integration procedure (Euler, Runge-Kutta, ...) type( particle ), intent(inout) :: prtcl Desired particle","tags":"","loc":"module/module_evaporation.html"},{"title":"module_particle – Fortran Program","text":"Define custom datatype \"particle\" Uses module_parameters Contents Derived Types particle Functions v_euclid mass_core vol_core mass_shell vol_shell Subroutines verify_shell verify_status set_dt Derived Types type, public :: particle Custom Datatype for Particle-Simulation Components Type Visibility Attributes Name Initial double precision, public, DIMENSION(dim) :: r Current Position [m] double precision, public, DIMENSION(dim) :: v Current Velocity [m/s] double precision, public, DIMENSION(dim) :: f Current Force [µN = µg·m/s] double precision, public :: d_core Particle Core Data (d = diameter [µm]) double precision, public :: d_shell Particle Shell Data (d = diameter [µm]) double precision, public :: T Temperature of particle [K] double precision, public :: time_elapsed Elapsed time [s] logical, public :: core_only Indicates if particle-shell is evaporated logical, public :: active Indicates if particle is still in the air double precision, public, DIMENSION(dim) :: v_wind Velocity of Wind [m/s] double precision, public :: T_environment Temperature of environment [K] double precision, public :: humidity Relative Humidity in environment [%] double precision, public :: dt Current Stepwidth [s] Functions public function v_euclid (prtcl) Euclidic norm of velocity of particle Arguments Type Intent Optional Attributes Name type( particle ), intent(in) :: prtcl Desired particle Return Value double precision public function mass_core (prtcl) Get mass of particle core [fg = femtogramm] Arguments Type Intent Optional Attributes Name type( particle ), intent(in) :: prtcl Desired particle Return Value double precision private function vol_core (prtcl) Get volume of particle core [µm³] Arguments Type Intent Optional Attributes Name type( particle ), intent(in) :: prtcl Desired particle Return Value double precision public function mass_shell (prtcl) Get mass of particle shell [fg = femtogramm] Arguments Type Intent Optional Attributes Name type( particle ), intent(in) :: prtcl Desired particle Return Value double precision private function vol_shell (prtcl) Get volume of particle shell [µm³] Arguments Type Intent Optional Attributes Name type( particle ), intent(in) :: prtcl Desired particle Return Value double precision Subroutines public subroutine verify_shell (prtcl) Verify if particle shell is completely evaporated Arguments Type Intent Optional Attributes Name type( particle ), intent(inout) :: prtcl Desired particle public subroutine verify_status (prtcl, t_total) Verify if particle is still active Arguments Type Intent Optional Attributes Name type( particle ), intent(inout) :: prtcl Desired particle double precision, intent(in) :: t_total Total Simulaiton Time public subroutine set_dt (prtcl, f_r) Set current stepwidth [s] Arguments Type Intent Optional Attributes Name type( particle ), intent(inout) :: prtcl Desired Particle double precision, intent(in) :: f_r Air resistance force [µN]","tags":"","loc":"module/module_particle.html"},{"title":"main – Fortran Program","text":"Uses numeric_integration particle_simulation Main Simulation Program Contents Variables config_file base_path num_of_variables concentration velocity v_wind T_environment humidity t_total data_array all_done breakpoint t_resolution timestamp n_cur Subroutines read_config write_to_file print_output Variables Type Attributes Name Initial character(len=128), parameter :: config_file = 'data/config.d' Relative Path to Configuration file character(len=128), parameter :: base_path = 'data/particle_simulation_result_' Relative Path to Result files (Extension needs to be added) integer, parameter :: num_of_variables = 23 Hard Coded Number of Variables that are present in output data array integer :: concentration Particle concentration in the air [x/m³] (0...30.000) double precision, DIMENSION(dim) :: velocity Intensity coefficient [%] (0...1) double precision, DIMENSION(dim) :: v_wind Velocity of Wind [m/s] double precision :: T_environment Temperature of environment [K] double precision :: humidity Relative Humidity in environment [%] (0...1) double precision :: t_total Total Simulation Time [s] double precision, DIMENSION(:,:), ALLOCATABLE :: data_array Output Data Array logical :: all_done Stop Simulation logical :: breakpoint Time breakpoint to print values double precision :: t_resolution Time resolution double precision :: timestamp Current timestamp integer :: n_cur Number of Iterations Subroutines subroutine read_config (filename) Read in parameter configuration from file Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename Filename subroutine write_to_file (filename_base, n_current) Write data to file Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename_base File-Basename integer, intent(in) :: n_current Current iteration number subroutine print_output (array) Print array to console Arguments Type Intent Optional Attributes Name double precision, intent(in), DIMENSION(concentration, num_of_variables) :: array Desired Array","tags":"","loc":"program/main.html"}]}